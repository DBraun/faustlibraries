//######################## probability.lib ######################################
// A library of probability-related functions. Its official prefix is `pr`.
//
// This library adds some functions for probability including temperature-based sampling
// and discrete-time Markov models.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/probability.lib>
//#################################################################################

/************************************************************************
************************************************************************
FAUST library file
Copyright (C) 2003-2025 GRAME, Centre National de Creation Musicale
----------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

ro = library("routes.lib");
ba = library("basics.lib");
si = library("signals.lib");
rm = library("reducemaps.lib");
no = library("noises.lib");


//--------------`(pr.)normalizeL1NonNegative`------------------------------
// Normalize several channels so that they sum to 1. This is the same
// as L1-normaliztion, except we assume that all of the input signals are
// non-negative and can therefore skip `abs` operations.
// This function can divide by zero if the input channels are all zero.
//
// #### Usage
//
// ```
// process = si.bus(N) : normalizeL1NonNegative(N) : si.bus(N);
// ```
//
// Where:
// * `N`: The number of values needed to be normalized.
//
// #### Example
//
// ```
// process = 0.1, 0.2, 0.4 : normalizeL1NonNegative(3) : _, _, _;
// ```
//
//----------------------------------------------------
normalizeL1NonNegative(N) = si.bus(N) <: si.vecOp((si.bus(N), summedBus), /)
with {
    summedBus = si.bus(N) :> _ <: si.bus(N);
};
declare normalizeL1NonNegative author "David Braun";
declare normalizeL1NonNegative license "MIT";


//--------------`(pr.)normalizeL1`------------------------------
// Normalize several channels so that their L1 length is 1.
// This can divide by zero if the input channels are all zero.
//
// #### Usage
//
// ```
// process = si.bus(N) : normalizeL1(N) : si.bus(N);
// ```
//
// Where:
// * `N`: The number of values needed to be L2-normalized.
//
// #### Example
//
// ```
// process = 0.1, 0.2, 0.4 : normalizeL1(3) : _, _, _;
// ```
//
//----------------------------------------------------
normalizeL1(N) = si.bus(N) <: si.vecOp((si.bus(N), summedBus), /)
with {
    l1length = par(i, N, abs) :> _;
    summedBus = l1length <: si.bus(N);
};
declare normalizeL1 author "David Braun";
declare normalizeL1 license "MIT";


//--------------`(pr.)normalizeL2`------------------------------
// Normalize several channels so that their L2 length is 1.
// This can divide by zero if the input channels are all zero.
//
// #### Usage
//
// ```
// process = si.bus(N) : normalizeL2(N) : si.bus(N);
// ```
//
// Where:
// * `N`: The number of values needed to be L2-normalized.
//
// #### Example
//
// ```
// process = 0.1, 0.2, 0.4 : normalizeL2(3) : _, _, _;
// ```
//
//----------------------------------------------------
normalizeL2(N) = si.bus(N) <: si.vecOp((si.bus(N), summedBus), /)
with {
    l2length = si.bus(N) <: si.dot(N) : sqrt;
    summedBus = l2length <: si.bus(N);
};
declare normalizeL2 author "David Braun";
declare normalizeL2 license "MIT";


//-----------------`(pr.)softmax`-------------------------------
// Apply softmax to logits to produce probability values.
// A high temperature value will flatten the probability distribution.
//
// #### Usage
//
// ```
// process = si.bus(N) : softmax(N, temp) : si.bus(N);
// ```
//
// Where:
//
// * `N`: The number of logits values.
// * `temp`: A temperature (strictly greater than zero) which adjusts the probabilities. A higher temperature yields a flatter distribution.
//
// #### Example
//
// ```
// process = (-.1, 0.2, 0.3, -.2) : softmax(4, 2.) : si.bus(4);
// ```
//
// #### References
// <https://en.wikipedia.org/wiki/Softmax_function>
//-------------------------------------------------------
softmax(N, temp) = subtractMaximum : par(i, N, exp(_/temp)) : normalizeL1NonNegative(N)
with {
    // We subtract the maximum to prevent overflow of `exp(x)`.
    subtractMaximum = si.bus(N) <: si.vecOp((si.bus(N), maxBus), -)
    with {
        maxBus = rm.parReduce(max, N) <: si.bus(N);
    };
};
declare softmax author "David Braun";
declare softmax license "MIT";


//-------------------`(pr.)softmaxMatrix`---------------------
// Apply softmax to a matrix of shape `NxN`. Note that
// the matrix values should be packed into a 1D list.
//
// #### Usage
//
// ```
// process = si.bus(N*N) : softmaxMatrix(N, temp) : si.bus(N*N);
// ```
//
// Where:
//
// * `N`: The length of the one dimension of the square matrix of logits values.
// * `temp`: A temperature (strictly greater than zero) which adjusts the probabilities. A higher temperature yields a flatter distribution.
//
// #### Example
//
// ```
// process = (0, .1, -.1, .2) : softmaxMatrix(2, 1.3) : si.bus(4);
// ```
//
//----------------------------------------------------
softmaxMatrix(N, temp) = par(i, N, softmax(N, temp, si.bus(N)));
declare softmaxMatrix author "David Braun";
declare softmaxMatrix license "MIT";


//----------------------`(pr.)cumsum`------------------------
// Calculate the cumulative sum of a list of numbers.
// Note that we don't assume that the list of numbers sums to 1.
// If you want to produce a cumulative density function, then you should use
// `cumsumNormalized`.
// 
// #### Usage
//
// ```
// process = si.bus(N) : cumsum(N) : si.bus(N);
// ```
//
// Where:
//
// * `N`: The number of values to process into a cumulative sum array.
//
// #### Example
// ```
// process = (0.1, 0.2, 0.3) : cumsum(3) : si.bus(3);
// ```
//
//----------------------------------------------------
cumsum(N) = seq(i, N-1, layer(i))
with {
    layer(i) = si.bus(i), summer, si.bus(N-2-i);
    summer(x, y) = x, x+y;
};
declare cumsum author "David Braun";
declare cumsum license "MIT";


//----------------------`(pr.)cumsumNormalized`----------------
// A version of `cumsum` that normalizes the input values so
// that they sum to one. The output of `cumsumNormalized` can be used
// as a cumulative density function.
// 
// #### Usage
//
// ```
// process = si.bus(N) : cumsumNormalized(N) : si.bus(N);
// ```
//
// Where:
//
// * `N`: The number of values to process into a normalized cumulative sum array.
//
// #### Example
//
// ```
// process = (0.1, 0.2, 0.3) : cumsumNormalized(3) : si.bus(3);
// ```
//
//------------------------------------------------------
cumsumNormalized(N) = normalizeL1NonNegative(N) : cumsum(N);
declare cumsumNormalized author "David Braun";
declare cumsumNormalized license "MIT";


// -------------`(pr.)markovModel`---------------------------------------------------
// A transition step of a discrete-time Markov model. It has two outputs,
// which are the previous state and the new state. You should implement
// logic to select between the previous state and the new state. A `select2`
// with a trigger accomplishes this. Then you should use recursion to take
// that selected state and feed it back into the model for subsequent transitions.
// 
// #### Usage
//
// ```
// process = markovModel(transitionMatrix, state) : _, _;
// ```
//
// Where:
//
// * `transitionMatrix`: a 1D list of transition probabilities. It starts with all transition
//   probabilities from state 0 to all states. Then from state 1 to all states, and so on. If
//   there are `N` states then `transitionMatrix` should have `N*N` total outputs.
// * `state`: the current state (an integer between 0 and `N-1`).
// 
// #### Outputs
// * `state`: the current state
// * `newState`: the new state
// 
// #### Example
//
// ```
// process = (markovModel(transitionMatrix):select2(t))~_
// with {
//   N = 3;
//   transitionMatrix = par(i, N*N, 1/N); // uniform probability
//   t = os.lf_imptrain(4);
// };
// ```
//
//---------------------------------------------------------------------------------------
markovModel(transitionMatrix, state) = state, newState
with {
    // compile-time constant way of selecting among `NUM_BUSES` buses, each with `BUS_SIZE` outputs.
    selectBus(BUS_SIZE, NUM_BUSES, i) = si.block(BUS_SIZE*i), si.bus(BUS_SIZE), si.block(BUS_SIZE*(NUM_BUSES-(i+1)));

    N = int(sqrt(outputs(transitionMatrix))); // Assume transitionMatrix is 1D and holds N*N signals.
    indices = par(i, N, i);
    pdf(i) = transitionMatrix : selectBus(N, N, i);
    newState = par(i, N, sampleFromPMF(indices, pdf(i))) : ba.selectn(N, state);
};
declare markovModel author "David Braun";
declare markovModel license "MIT";


//-----------------`(pr.)sampleFromPMF`----------------------------------
// This function samples from a probability mass function (PMF).
// A PMF is a function that gives the probability that a discrete
// random variable is exactly equal to some value. The values are
// provided by the `values` argument, and their corresponding
// probabilities (which must each be between 0 and 1) are the
// `probabilities` argument. Note that a **PDF** is for
// continuous variables, so its values can be above 1.0.
// 
// #### Usage
//
// ```
// process = sampleFromPMF(values, probabilities) : _;
// ```
//
// Where:
//
// * `values`: a list of `N` values, like the x-axis of a PMF.
// * `probabilities`: a list of `N` probabilities, like the y-values associated with each of the x-axis values.
// 
// #### Example
//
// ```
// process = sampleFromPMF((0, 1, 2), (.5, .2, .3)) : _;
// ```
//
//---------------------------------------------------------------
sampleFromPMF(values, probabilities) = values, cumsumNormalized(N, probabilities)
    : ro.interleave(N, 2) : rm.parReduce(selectPair, N) : _,!
with {
    N = outputs(values); // assume outputs(values)==outputs(probabilities)
    // Use selectPair to get the value associated with the lowest cumulative probability value `p` such that `uniformNoise<=p`.
    // Let `v0` and `v1` be the values associated respectively with the probabilities `p0` and `p1`.
    // Assume `p0<=p1` due to our usage of cumsumNormalized and how `rm.parReduce` works.
    // If `uniformNoise<p0`, then return tuple `(v0, p0)`, else `(v1, p1)`.
    selectPair(v0, p0, v1, p1) = ba.select2stereo((uniformNoise<=p0), (v1, p1), (v0, p0));
    
    // create uniform noise between 0 and 1.
    uniformNoise = .5+.5*no.noise; // todo: use no.rnoise if possible
};
declare sampleFromPMF author "David Braun";
declare sampleFromPMF license "MIT";


// process = hgroup("Markov", (markovModel(transitionMatrix):select2(t))~_)
// with {
//     t = os.lf_imptrain(4);
//     N = 4;
//     temp = vslider("[2] Temperature", 1, 0.0001, 30, .0001);
//     transitionMatrix = vgroup("[0] Transition Matrix", par(i, N, par(j, N, hslider("h:[%2i] State %i To/[%2j] State %j [style:knob]", ba.if(((i+1)%N)==j, 2, -2), -4, 4, .01)))) : softmaxMatrix(N, temp);
//     // transitionMatrix = vgroup("[0] Transition Matrix", par(i, N, par(j, N, hslider("h:[%2i] State %i To/[%2j] State %j [style:knob]", ba.if(((i+1)%N)==j, 1, 0), 0, 1, .01))));
//     // transitionMatrix = (
//     //     0, 1, 0, 0, // from state 0 to state 0, 1, 2, 3
//     //     0, 0, 1, 0, // from state 1 to state 0, 1, 2, 3
//     //     0, 0, 0, 1, // from state 2 to state 0, 1, 2, 3
//     //     1, 0, 0, 0  // from state 3 to state 0, 1, 2, 3
//     // );
// };


// This is an example of a non-stationary Markov model.
// Instead of a single Markov model, there are `NUM_STEPS` models numbered 0 through `NUM_STEPS-1`.
// We cycle through the models in a fixed order.
// We initialize the model parameters so that the sequence is
// always [0, 1, 2, 3, 0, 1, 2], and then ending on a random choice.
// process = hgroup("Markov", ((markovModel(transitionMatrix):select2(t))~_):visualizer )
// with {

//     myCounter(numStates, t) = tick~_
//     with {
//         tick(state) = select2(t, state, (state+1)%numStates);
//     };

//     N = 4;
//     NUM_STEPS = 8;
    
//     stepIndex = myCounter(NUM_STEPS, t);

//     t = os.lf_imptrain(4);
    
//     temp = vslider("[2] Temperature", 1, 0.0001, 30, .0001);
//     logit_v = 2;
//     matrix(k) = tgroup("Transition Matrix", vgroup("[0] T%2k", par(i, N, par(j, N, hslider("h:[%2i] State %i To/[%2j] State %j [style:knob]", default(i, j, k), 0-logit_v, logit_v, .01)))))
//     with {
//         default(i, j, k) = ba.ifNcNo(2, 1, k==0, ba.if(j==0, logit_v, -logit_v), k==(NUM_STEPS-1), 0, ba.if(((i+1)%N)==j, logit_v, -logit_v) );
//     };
//     transitionMatrix = par(i, NUM_STEPS, matrix(i)) : ba.selectbus(N*N, NUM_STEPS, stepIndex) : softmaxMatrix(N, temp);

//     visualizer = seq(i, NUM_STEPS, makeCol(i))
//     with {
//         makeCol(i) = seq(j, N, _<: attach(_, ( (_==j)&(i==stepIndex) : vbargraph("h:[1]Visualizer/v:[%2i]T%2i/[%2j] State %j [style:led]", 0, 1))));
//     };
// };